One thing to understand with DS/A is that sometimes there isn't one answer. Meaning for different algorithms and data structures, you can have different Time/Space complexities depending on how they are implemented, if there was usage of dynamic programming that contains techniques such as memoization and more. The programming languages used also impact the DS/A used, however the Space/time complexities focuse solely on the efficiency of said DS/A ignoring external software/hardware impacts. Although it goes without saying that any programmer should put these into consideration when choosing said DS/A.

Furthermore, this also means that there is no one algorithm that fits every situation but rather a good programmer needs to understand and know which algorithm or data structure best fits your needs at the time. Thus, the results are for MY implementations.

One thing to note is that the input values along side the runtimes should match with the behaviour of the DS/A. For example if it is an algorithm with linear Big O time complexity, then the input values and runtime should also be linear, else the plotted graph will be highly innacurate to the actual behaviour of the algorithm.



    Recurssion:

            Factorial:
                Time: Big O(n!)
                Space:Big O(n)

            Fibonacci:
                Time: Big O(n^2)
                Space:Big O(n)


    Searching:

            Linear:
                Time: Big O(n)
                Space:Big O(1)
        
            Binary:
                Time: Big O(log(n))
                Space:Big O(1)


    Sorting:
    
            Bubble:
                Time: Big O(n^2)
                Space:Big O(n)
            Quick:
                Time: Big O(n log(n))
                Space:Big O(log(n))