One thing to understand with DSA is that sometimes there isn't one answer. Meaning for different algorithms and data structures, you can have different Time/Space complexities depending on how they are implemented, the programming language that was used, if there was usage of dynamic programming that contains techniques such as memoization and more. 

Furthermore, this also means that there is no one algorithm that fits every situation but rather a good developer needs to understand and know which algorithm or data structure best fits your needs at the time. Thus, the results below are for MY implementations.

One thing to note is that the input values along side the runtimes should match with the behaviour of the DS/A. For example if it is an algorithm with linear Big O time complexity, then the input values and runtime should also be linear, else the plotted graph will be highly innacurate to the actual behaviour of the algorithm.



    Recurssion:
        Factorial:
            Time: Big O(n!)
            Space:Big O(n)

        Fibonacci:
            Time: Big O(n^2)
            Space:Big O(n)


    Searching:
        Linear:
            Time: Big O(n)
            Space:Big O(1)
    
        Binary: